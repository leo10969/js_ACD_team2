<html>
    <head>
        <meta charset="utf-8"/>
    </head>
    <script src="arrow.js"></script>
    <body>
        <div id="add_node">
            <p>Node</p>
            name<input type="text" id="node_name" value=""></input>
            group<input type="text" id="group" value=""></input>
            rank<input type="text" id="rank" value=""></input>
            <input type="button" value="追加" onclick="addNode(document.getElementById('node_name').value, document.getElementById('group').value, document.getElementById('rank').value);"></input>
        </div>

        <div id="add_link">
            <p>Link</p>
            label<input type="text" id="link_name" value=""></input>
            from <input type="text" id="from_node" value=""></input>
            to <input type="text" id="to_node" value=""></input>
            <input type="button" value="追加" onclick="addLink(document.getElementById('link_name').value, document.getElementById('from_node').value, document.getElementById('to_node').value);"></input>
        </div>

        <div id="container"></div>
        <script type="text/javascript">
        var cvs = document.createElement("canvas");
        cvs.width = 500;
        cvs.height = 500;
        document.getElementById('container').appendChild(cvs);
  
        var ctx = cvs.getContext("2d");
        
        var links = {};
        var nodes = {};
        
        // Functions
        function addNode(node_name, group, rank) {
            var node = new Node();
            node.name = node_name;
            node.group = group;
            node.x = 500*Math.random();
            node.y = 500*Math.random();
            nodes[node_name] = node;
            links[node_name] = {};
        }

        function addLink(link_name, from_node_name, to_node_name) {
            var link = new Link(nodes[from_node_name], nodes[to_node_name]);
            link.set_label(link_name);
            links[from_node_name][to_node_name] = link;
        }

        function calcForce() {
            var k = 0.001; // ばね定数
            var stableDistance = 220; // ばねの自然長
            var nodeList = Object.values(nodes); // Nodeオブジェクトの配列
            for (var i = 0; i < nodeList.length; i++) {
                var node1 = nodeList[i];
                for (var j = i+1; j < nodeList.length; j++) {
                    var node2 = nodeList[j];
                    var dx = node1.x - node2.x;
                    var dy = node1.y - node2.y;
                    var d = Math.sqrt(dx*dx + dy*dy);
                    if(node1.name in links[node2.name] || node2.name in links[node1.name]) {
                        // ばねの計算
                        var f = k * (stableDistance - d);
                        node1.x += dx * f;
                        node1.y += dy * f;
                        node2.x -= dx * f;
                        node2.y -= dy * f;
                    } else {
                        // 斥力・引力の計算
                    }
                }
            }
        }

        function drawLinks(ctx) {
            for (var n1 in links) {
                for (var n2 in links[n1]) {
                    if(n1 in links[n2] && links[n1][n2].label != links[n2][n1].label) {
                        ctx.save();
                        ctx.translate(15*Math.cos(links[n1][n2].theta + Math.PI/2), 15*Math.sin(links[n1][n2].theta + Math.PI/2));
                        links[n1][n2].draw(ctx);
                        ctx.restore();
                    } else {
                        links[n1][n2].draw(ctx);
                    }
                }
            }
        }

        // Class
        function Link(from_node, to_node) {
            this.from_node = from_node;
            this.to_node = to_node;
            this.theta = Math.atan2((this.to_node.y - this.from_node.y), (this.to_node.x - this.from_node.x));
            this.label = "";
            this.bidirection = false;
            this.arrow = new arrow(
                        this.from_node.x + this.from_node.r * Math.cos(this.theta), 
                        this.from_node.y + this.from_node.r * Math.sin(this.theta), 
                        this.to_node.x - this.to_node.r * Math.cos(this.theta), 
                        this.to_node.y - this.to_node.r * Math.sin(this.theta), 
                        [0, 1, -20, 1, -20, 15]
            );

            this.set_label = function(label) {
                this.label = label;
                this.arrow.label = label;
            };

            this.draw = function(ctx) {
                this.theta = Math.atan2((this.to_node.y - this.from_node.y), (this.to_node.x - this.from_node.x));
                this.arrow.update(
                        this.from_node.x + this.from_node.r * Math.cos(this.theta), 
                        this.from_node.y + this.from_node.r * Math.sin(this.theta), 
                        this.to_node.x - this.to_node.r * Math.cos(this.theta), 
                        this.to_node.y - this.to_node.r * Math.sin(this.theta), 
                        [0, 1, -20, 1, -20, 15]
                );
                this.arrow.draw(ctx);
            }
        }

        function Node() {
            var me = this;
         
            this.x = 0;
            this.y = 0;
            this.r = 50;
            this.isDragged = false;
            this.name = "";
            this.draw = function(ctx) {

                ctx.fillStyle = "gray";
                ctx.strokeStyle = "black";
                ctx.beginPath();
                ctx.arc(me.x, me.y, me.r, 0, 2 * Math.PI, true);
                ctx.fill();
                ctx.stroke();
                ctx.closePath();
                ctx.beginPath();
                ctx.fillStyle = "white";
                ctx.textBaseline = "middle";
                ctx.fillText(this.name, this.x-ctx.measureText(this.name).width/2, this.y);
                ctx.fill();
            };

            cvs.addEventListener("mousedown", function(e) {
                var dx = me.x - (e.clientX - cvs.getBoundingClientRect().left);
                var dy = me.y - (e.clientY - cvs.getBoundingClientRect().top);
                me.isDragged = Math.sqrt(dx * dx + dy * dy) < me.r;
            });
         
            cvs.addEventListener("mousemove", function(e) {
                if (me.isDragged) {
                    me.x = e.clientX - cvs.getBoundingClientRect().left;
                    me.y = e.clientY - cvs.getBoundingClientRect().top;
                }
            });
         
            cvs.addEventListener("mouseup", function(e) {
                me.isDragged = false;
            });
        }

        function render() {
            ctx.clearRect(0, 0, 500, 500);
            ctx.strokeStyle = "gray";

            // Calculate force
            calcForce();

            // Draw links
            drawLinks(ctx);

            // Draw nodes
            for (var name in nodes) {
                nodes[name].draw(ctx);
            }
        }
         
        setInterval(render, 30);
    </script>
    </body>
</html>